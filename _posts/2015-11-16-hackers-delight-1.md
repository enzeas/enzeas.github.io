---
layout: post
title:  "Hacker's Delight(1)"
author: E君
date:   2015-11-16
categories: 技巧
tags: 笔记
---

### 基础知识 ###

将最右侧的1位改成0位(0101 1000 => 0101 0000):

**x&(x-1)**

- 可以检测一个unsigned int是否为2的幂。

检测一个unsigned int是否为2<sup>n</sup>-1的形式:

**x&(x+1)**


析出最右侧的1位，如果没有1则生成所有位均为0的数字(0101 1000 => 0000 1000):

**x&(-x)**


析出最右侧的0位，如果没有0则生成所有位均为1的数字(1010 0111 => 0000 1000):

**~x&(x+1)**

构造识别后缀0的掩码，如果x=0则生成所有位都为1的数字(0101 1000 => 0000 0111):
 
**~x&(x-1)**

**~(x\|-x)**

**(x&-x)-1**

构造识别最右侧的1位和后缀0的掩码，如果x=0则生成所有位都为1的数字(0101 1000 => 0000 1111):

**x^(x-1)**


向右侧传播最右侧的1位，如果x=0则生成所有位均为1的数字(0101 1000 => 0101 1111):

**x\|(x-1)**

将最右侧连续的1位串改成0位串(0101 1000 => 0100 0000):

**((x\|(x-1))+1)&x**

- 可以检测一个unsigned int是否具有2<sup>j</sup>-2<sup>k</sup>的形式。

上面的公式都具有**对偶性**。

交换描述中的0和1，那么在公式中，用**x+1**替换**x-1**，用**x-1**替换**x+1**，用**~(x+1)**替换**-x**，用**&**替换**\|**，用**\|**替换**&**，**~x**不变，就得到一个新的正确的描述和公式。

举个栗子，将一个数字的最右侧0位改成1位，如果没有0位则生成所有位都为1的数字(1010 0111 => 1010 1111)：

**x\|(x+1)**
